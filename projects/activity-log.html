<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="stylesheet" href="/styles/projects.css">
    <script src="/scripts/script.js" defer></script>
    <title>Activity Log — Thierry Kunda's</title>
</head>

<body>
    <header>
        <h1>Thierry Kunda's</h1>
        <nav>
            <a href="#">Home</a>
            <a href="#">My work</a>
            <a href="#">Products & Services</a>
            <a href="#">Blog</a>
            <a href="#">About me</a>
        </nav>
    </header>
    <main>
        <h1>Activity Log</h1>
        <p class="post-date">Published on <time datetime="2024-12-26">December 27<sup>th</sup>, 2024</time>.</p>
        <section>
            <h2>The story behind its appearance</h2>
            <div class="content">
                <p>Did I tell you I'm currently working in the data field? Huh? Well...this information is quite
                    important to understand how the idea was born.
                    As stated in my <a href="#">About me</a> page — I hope you have already read it...right? — I'm an
                    apprentice in a banking company.
                    One of my missions is to produce and publish <strong>BI reports</strong> for other entities, based
                    on data from different types of sources, such as extraction files, database queries, REST APIs and
                    so on.
                    We are using <strong>Microsoft Power BI</strong> as the main tool.</p>
                <p>Since I'm working in a team of Data Scientist and Engineers, we are also using Power BI to track and
                    compute the time spent on the subjects we are working on.</p>

                <p>We use an Excel file to store all the information related to those subjects. However it becomes more
                    and more tiring to manually estimate the average time on specific and repetitive tasks,
                    as we have to update the file each time.
                    At some point, I told myself: <span class="quote">Everything could be simpler if there was a piece
                        of software that could resolve this issue</span> —
                    and make coffee, but we all know the answer to this request unfortunately...</p>
                <p>As I'm used to version my college and personal projects with <strong>Git</strong> — like
                    99.999999...% of software developers — I thought this system as one of the best when it is
                    about keeping track on stuff that has long lives in their usage and welcomes well collaboration and
                    nice self-documented project progress —
                    with commit messages, tags, merges, issues,...
                </p>
                <p>At some point, I thought it would be interessing to pick some of the basic concepts of Git and bring
                    them into any software that needs it. That is how <strong>Activity Log</strong> was thought out in
                    the process:
                    tracking topics/subjects/projects and breaking them down into tasks completed as you go along.
                    <span class="quote">
                        Need to switch to another subject? No problem! Hit the X command.
                        Need to register a new subject? Hit the Y command.
                        Want to see all the tasks you have done today? Hit that Z command. See? You are productive
                        today! Keep going!
                    </span>
                </p>
                <p>When I was sure building something new would solve a 'real-life' issue — and not some too specific or
                    imaginary problem —
                    I jumped right in this occasion to start a new personal project — among the other hundreds of dead
                    projects that keep calling me in dreams, or nigthmares...</p>
                <p>Now let's see how the tool was built. Spoiler: it was not as smooth as I thought it would be. Would
                    not be interesting if everything was easy
                    from the get-go, don't you agree?
                </p>
            </div>
        </section>
        <section>
            <h2>The development process — yap session unlocked</h2>
            <div class="content">
                <h3>Choosing the technology — Rust? Seriously?</h3>
                <p>Before writing any piece of code, I had to choose (obviously) a programming language.
                    The first thing I told myself was: <span class="quote">
                        I want to be effective and productive, not processing a lot on the system design side of stuff
                        nor any
                        architecture details.
                    </span>
                    The mantra was clear: <span class="quote">build fast, release fast, check fast, breakfast</span> —
                    not sure about the last one though.</p>
                <p>Therefore I picked at first...<strong>Powershell</strong>! Suprising? Well there are several reasons
                    for choosing this language:
                <ul>
                    <li>Having something close to your operating system — in a <span
                            class="quote">close-to-native</span> way of thinking —
                        reduces all the <span class="quote">toolbox</span> effect
                        you usually have in the compiling process —
                        e.g.: <strong>Node.js</strong> in the web development field with frontend and full-stack
                        frameworks.</li>
                    <li>Along with this reason, the language is simple by conception. No OOP, no complex data structures
                        to handle.
                        You just define a CLI command right of the bat.
                    </li>
                    <li>I wanted a new challenge. As I have never built something with a pure scripting language — a
                        system language to be more precise —,
                        I could add something to my resume, even for a small side project. I don't loose anything by
                        doing that, just earning new knowledges and understanding
                        on software development. <span class="quote">#MambaMentality</span></li>
                </ul>
                </p>
                <p>The thing is...one of my goals was to provide a tool to any platforms — primarly Windows, MacOS and
                    Linux.
                    But it turns out I would have to build two versions of the same tool as I will be using, for
                    Unix-based OS,
                    <strong>Bash</strong>.
                    I was quite hopeful on the developer experience of Bash as I experienced the way Powershell was
                    friendly in their easiness of use.
                </p>
                <p>...It was the opposite. It was the first time I've had this opinion:
                    <span class="quote">Windows is beating the sh*t out of Linux in terms of DX</span>.
                    And it was quite frightening how true it was at the moment. Rust became my second option really
                    quick, because:
                <ol>
                    <li>Rust is a compiled languages that can target different platforms.</li>
                    <li>It is a language I have used in sandbox coding, which led me to understand concepts like <span
                            class="quote">ownership</span>,
                        <span class="quote">borrow-checking</span> and other witchcraft done with <span
                            class="quote">functional programming</span>
                        and a bit of <span class="quote">OOP</span> (picking the best sides of it).
                    </li>
                    <li>I wanted to create something with,
                        not knowing exactly <span class="quote">what</span> I should do.
                        So I took the opportunity to make something concrete with this quite interesting language.</li>
                    <li><span class="quote">But why don't you use Python?</span>
                        There are multiple reasons not to use Python in this case, but one that stands out well is the
                        absence of a typing and a
                        pattern matching systems that I could leverage to organize in a nice way my code and make it
                        comprehensible at first glance.</li>
                </ol>
                </p>
                <p>For those who do not know what kind of language Rust is, let me break it down to you:
                    it is a static typing compiled language that can be compared — to some extent — to other low-level
                    languages such as:
                <ul>
                    <li>C: it tends to be considered as the purest form of manual memory manipulation — also known as
                        <span class="quote">shoot on your foot if you feel confident</span> language
                    </li>
                    <li>C++: it is basically the C language with OOP concepts, which adds more abstractions to the code
                    </li>
                    <li><strong>Golang</strong> (or Go): it is nearly the same generation as Rust in the modern
                        languages era and has the common purpose
                        to bring new concepts to low-level development in order to lessen the burden of building
                        system-targeted software.
                    </li>
                </ul>
                </p>
                <article>
                    <p>Actually the project could have been thought through Golang, there is not really a better
                        language in the context of creating
                        a command line application. <br>
                        The main difference relies on which concepts you favor in the building process and how much you
                        are comfortable considering the DX.</p>
                    <p>If there are any major differences in their way of designing and maintaining new stuff that I
                        could tell to a fellow sofware engineer, I would say the following: <br>
                        <span class="quote">
                            If you are the type that rushes their lunch meal because they feel like they are loosing the
                            time they could have spend to advance on their tasks, you will likely
                            enjoy Golang — boring language but trully effective and fast. <br>
                            On the other hand, if you enjoy free time spending X time on stuff knowing it might not be
                            useful later, just for the sake of it or for learning in the hard way,
                            you will definitely appreciate Rust.
                        </span>
                    </p>
                </article>
                <p>Rust brings <strong>security</strong> at the center of software development conception. Thanks to its
                    ownership system, it provides an alternative technique
                    to manual memory allocation (e.g.: C and C++) — giving nice performances but risky as it raises bugs
                    presence — and to garbage collection (e.g.: Python, Ruby, Go)
                    — more secure as it is automated by the language through another mini-program called the <span
                        class="quote">garbage collector</span>, but slows down the code execution.
                </p>
                <article>
                    <p>NB : There is not a direct link between memory allocation, programming language level and typing
                        system. The mix between those three parameters is defined by what you expect
                        your language to be good at and limited on specific tasks.</p>
                    <p>A last parameter that could be added to the list is the compilation/interpretation method:
                        <span class="quote">when</span> — for each line? on the whole program? — your source code is
                        converted to binaries — bytecode or pure binaries? — and executed in the overall process,
                        and sometimes <span class="quote">what</span> is it doing this stuff — bare metal? virtual
                        machine?...
                    </p>
                </article>
                <p>I will not deep dive on the many memory allocation methods in the overall programming language
                    spectrum, but to make it simple:
                    the idea behind the creation of Rust was to push all error checking steps to the compilation side.
                    Therefore Rust became a safe language as it
                    does not allow any code to be compiled that could cause bugs. There are still bug sources that
                    happen to exist in the runtime process, but they tend be forcibly present
                    as it is not possible to suppress them by design.
                </p>
                <p>Additionally, the development team of the language brought both <strong>functional
                        programming</strong> and <strong>OOP</strong> principles in the best way into the language.
                    Again I will not give details on why functional programming is cool — trust me, IT IS! — and how
                    they succeeding in not messing architecture and code maintainance by bringing the best
                    of OOP — with just interfaces (called <span class="quote">traits</span>) and a light approach on
                    inheritence and polymorphism.
                </p>
                <h3>Features — great reminder to not build a swimming pool <span class="quote">in</span> a spaceship
                </h3>
                <p>I'm someone who can be too much inventive when it is about creating features for a tool. But
                    it often leads me
                    to create some kind of <span class="quote">Frankenstein-ish</span> product which does not focus on
                    the original solution thought to the problem I am trying to solve.
                    The challenge here is was the following:
                    <span class="quote">How can I create a software that can be interesting
                        enough for any user to enjoy using it day by day, and concise enough not to lose their interest?
                    </span>
                <p>The plan to keep being consistant was not something grand.
                    I used iterations on my thought process with the following steps:
                    <ol>
                        <li>Telling myself: <span class="quote">What is missing?</span> Or
                            <span class="quote">I want to have/do X thing but it's not (yet) available...</span></li>
                            <li><span class="quote">Is anyone else would feel the same about that?
                                Am I tripping?</span></li>
                            <li>To be sure, I'm asking to other potential user — on forums, social media, to my mom, siblings,
                                even Santa Claus if needed — what are their thoughts on X stuff, and if they think like me about it.</li>
                            <li>Thus, I add the feature based on their feedbacks. It does not have to be <span class="quote">exactly</span>
                            the one I thought originally but a conception that matches everyone's overall expectation.</li>
                    </ol>
                <p>That is explaining — or mostly trying to explain — the title about the <span class="quote">swimming pool in a spaceship</span>:<br>
                    At first you think that being able to make it possible would be incredible for spacemen — can't they just chill sometimes, right? —,
                    but at second thought you realize it will jeopardize the essential purpose of a spaceship which is visiting 
                    and discover new <span class="quote">out-of-earth</span> elements.
                </p>
                <p>After yapping that much on my thought process — looking like some fellow guy with ADHD...
                    (not disrespecting ADHD people, You all are awesome!) —, I think you've got an idea on what is trully hard
                    in creating something, which may not be the technical part of it.</p>
                </p>
                </p>
                <h3>Project structure and code organization — I love spaghettis! Not so much in my code...</h3>
                <p>This topic is kinda tough to broach. How will I start on this?...</p>
                <p>First truth: you cannot predict at an early stage how your code is going to be organized.
                    Especially when the project life cycle is based on iterations like in the <strong>Agile</strong> approch.
                    Do not complicate things on trying to predict elements that you <span class="quote">might</span> use
                    later — like adding a class or a method not implemented yet but 'certainly' useful in the future. Your
                    are not a fool, you know that the needs and requirements will change, and being flexible makes everything
                    easier than what you think.
                </p>
                <p>In the other hand, not knowing the future design does not mean not knowing how
                    to design a <span class="quote">good enough</span> codebase. Do not try reinviting the wheel and go learn
                    design patterns and architecture rules that will help you produce clean code.
                    Again, go by iteration:
                    <ol>
                        <li>Make sure the piece of code your are working on is comprehensible for external developers.</li>
                        <li>If it's not the case, break it into smaller pieces with logical relations.</li>
                        <li>Too much lines? Break it into different files. Do not overdo it ! Switching between files to understanding
                            how things are related can be redundant and tiring.
                        </li>
                        <li>If you are not sure about the decomposition process you are applying, add docstring to your code or create any kind
                            of documentation — e.g. create <strong>Confluence</strong> pages or sections, add neat details to the PR messages,...
                            — to explain why you are doing all of this. It can be quite effective as you could catch yourself writing
                            some gibberish and tell yourself <span class="quote">Well...I'm not even convinced myself...Why someone else
                                would be at this point!?
                            </span>

                        </li>
                        <li>If you really want to be sure at some point, just try building in your mind the same source code in a single file you
                            wrote so far. If it looks horrendous, break it. Still looking ugly? Break it again...until
                        you tell yourself: <span class="quote">What I have done until now is not that bad!</span></li>
                    </ol>
                </p>
                <article>
                    <p>Documentation is really important as it gives more contextual information on technical and business aspects of the project.
                        Tools like <strong>Confluence</strong> are useless without collaborators contribution.
                    </p>
                    <p>
                        Have you ever been in a situation
                        where you do not have specific pieces of information that would help you unlock an issue? Searching through <strong>StackOverflow</strong> and
                        <strong>Reddit</strong> hoping to hit a comment about an author who faced a similar problem and provides clues, but not finding anything relevant? Think
                        about it next time and be the savior of your teammates!
                    </p>
                </article>
                <h3>What about Git workflow? Testing?</h3>
                <p>TLDR: None of them were really used — at least not for the first version.</p>
                <p>For single-developer team, there is no use to create a complete Git workflow, unless you want
                    provide contextual information on features or simply group them into branches.
                    For instance, it is common to create two branches, one for the releases called
                    <span class="quote">main</span> or <span class="quote">master</span> — which is created by default when
                    initializing a Git repository — and an other one called <span class="quote">dev</span> for ongoing
                    modifications of the source code — e.g. new features, bug fixes, documentation, code refactoring, etc. 
                </p>
                <p>Those two branches are sufficient until I add another developer to the project. Adding more branches
                    will turn really quick to something too <span class="quote">overkill</span>.
                </p>
                <p>Additonally, developers tends to forget that testing is really time-consuming and has to be efficient to add any
                    value to the code. If not, it just adds complexity to the code.
                    That is why I preferred not to add testing cases to a source code that does not so much work that cannot
                    be checked manually.
                </p>
                <article>
                    <p>You must assume that <strong>testing is really important</strong> and will be present inevitably.
                    It saves you from ridiculous situations that could appear at any time.</p>
                </article>
            </div>
        </section>
        <section>
            <h2>The first release</h2>
            <div class="content">
                <h3>From <strong>cargo</strong> for the rustaceans</h3>
                <p>For developers that already have <span class="quote">cargo</span> — the official package manager of Rust —, they
                    can hit the following command:
                </p>
                <code title="Tap to copy to the clipboard">cargo install activitylog</code>
                <p>More information are available <a href="https://crates.io/crates/activitylog">here</a>. </p>
                <h3>Directly as binaries for the OGs</h3>
                <p>You can download the executable based on one of the specified platforms for version v0.1.0:
                    <div class="downloads">
                        <a href="/softwares/al-windows.exe" download="activitylog-win.exe">Download for Windows</a>
                        <a href="/softwares/al-linux-x86_64.exe" download="activitylog-linux_x86_64.exe">Download for Linux x86 — 64 bits</a>
                        <a href="/softwares/al-linux-arm_64.exe" download="activitylog-linux_arm_64.exe">Download for Linux ARM — 64 bits</a>
                        <a href="/softwares/al-linux-arm_32.exe" download="activitylog-linux_arm_32.exe">Download for Linux ARM — 32 bits</a>
                    </div>
                </p>
                <p>
                    NB : Unfortunately, there is no available version for MacOS executable distribution at the moment.
                    MacOS user must have <span class="quote">Rust</span> and <span class="quote">cargo</span> on their machine
                    to install the tool, using the <span class="quote">cargo install</span> command. I will be working on it in a future release.
                </p>
            </div>
        </section>
    </main>
    <footer>&copy; Thierry Kunda</footer>
</body>

</html>